---
layout: blog
title: FUSE for Linux Exploitation 101
tags: linux-exploitation binary-exploitation
comments: true
date: 2022-11-21
---

During the past few weeks, my friend [@kiks](https://1day.dev/) and I started to develop an exploit for CVE-2022-2602: it's an `io_uring` UAF.
We already completed the exploit using the `userfaultfd` technique to pause a kernel thread.
Unfortunately, this technique is dead (thank you, `vm.unprivileged_userfaultfd` :/ ), so we started searching a good replacement for `userfaultfd`.

While reading [chompie's blogpost](https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel) about `io_uring`, I stumbled upon FUSE.

In this blogpost I'll try to present to you my take on FUSE for Linux Exploitation :)

TLDR: FUSE filesystem allows users to pause a kernel thread, implementing a blocking read/write FUSE operation.

## What is FUSE?

FUSE (Filesystem in USErspace) is a feature that allows users (**also unprivileged users**) to create fileystems in userspace.

FUSE architecture is composed of 3 main parts:

* Fuse kernel module, which forwards requests on FUSE files to the user-space callbacks.
* `libfuse`, which is the userspace component.
* `fusermount`, an utility used to unmount fuse filesystems.

### A simple FUSE filesystem

In order to write a simple filesystem in userspace, we need to use the `fuse.h` header in C programs.

Inside `fuse.h`, the [`struct fuse_operations`](https://github.com/libfuse/libfuse/blob/master/include/fuse.h#L310) is defined.

<!-- ```
struct fuse_operations {
	
	int (*getattr) (const char *, struct stat *, struct fuse_file_info *fi);
	
	int (*readlink) (const char *, char *, size_t);

	int (*mknod) (const char *, mode_t, dev_t);
	
	int (*mkdir) (const char *, mode_t);

	int (*unlink) (const char *);

	int (*rmdir) (const char *);

	int (*symlink) (const char *, const char *);

	int (*rename) (const char *, const char *, unsigned int flags);

	int (*link) (const char *, const char *);

	int (*chmod) (const char *, mode_t, struct fuse_file_info *fi);

	int (*chown) (const char *, uid_t, gid_t, struct fuse_file_info *fi);

	int (*truncate) (const char *, off_t, struct fuse_file_info *fi);

	int (*open) (const char *, struct fuse_file_info *);

	int (*read) (const char *, char *, size_t, off_t,
		     struct fuse_file_info *);

	int (*write) (const char *, const char *, size_t, off_t,
		      struct fuse_file_info *);

	int (*statfs) (const char *, struct statvfs *);

	int (*flush) (const char *, struct fuse_file_info *);

	int (*release) (const char *, struct fuse_file_info *);

	int (*fsync) (const char *, int, struct fuse_file_info *);

	int (*setxattr) (const char *, const char *, const char *, size_t, int);

	int (*getxattr) (const char *, const char *, char *, size_t);

	int (*listxattr) (const char *, char *, size_t);

	int (*removexattr) (const char *, const char *);

	int (*opendir) (const char *, struct fuse_file_info *);

	int (*readdir) (const char *, void *, fuse_fill_dir_t, off_t,
			 struct fuse_file_info *, enum fuse_readdir_flags);

	int (*releasedir) (const char *, struct fuse_file_info *);

	int (*fsyncdir) (const char *, int, struct fuse_file_info *);

	void *(*init) (struct fuse_conn_info *conn,
		       struct fuse_config *cfg);

	void (*destroy) (void *private_data);

	int (*access) (const char *, int);

	int (*create) (const char *, mode_t, struct fuse_file_info *);

	int (*lock) (const char *, struct fuse_file_info *, int cmd,
		     struct flock *);

	 int (*utimens) (const char *, const struct timespec tv[2],
			 struct fuse_file_info *fi);

	int (*bmap) (const char *, size_t blocksize, uint64_t *idx);

#if FUSE_USE_VERSION < 35
	int (*ioctl) (const char *, int cmd, void *arg,
		      struct fuse_file_info *, unsigned int flags, void *data);
#else
	int (*ioctl) (const char *, unsigned int cmd, void *arg,
		      struct fuse_file_info *, unsigned int flags, void *data);
#endif

	int (*poll) (const char *, struct fuse_file_info *,
		     struct fuse_pollhandle *ph, unsigned *reventsp);

	int (*write_buf) (const char *, struct fuse_bufvec *buf, off_t off,
			  struct fuse_file_info *);

	int (*read_buf) (const char *, struct fuse_bufvec **bufp,
			 size_t size, off_t off, struct fuse_file_info *);

	int (*flock) (const char *, struct fuse_file_info *, int op);

	int (*fallocate) (const char *, int, off_t, off_t,
			  struct fuse_file_info *);

	ssize_t (*copy_file_range) (const char *path_in,
				    struct fuse_file_info *fi_in,
				    off_t offset_in, const char *path_out,
				    struct fuse_file_info *fi_out,
				    off_t offset_out, size_t size, int flags);

	
	off_t (*lseek) (const char *, off_t off, int whence, struct fuse_file_info *);
};
```
-->
It contains all function pointers to callbacks that the kernel module will use to handle different operations on FUSE files.

Another important element inside `fuse.h` is the `fuse_main` function. Its signature is: `fuse_main(int argc, char **argv, const struct fuse_operations *op, void *private_data)`.

This is the entry point of the filesystem: it takes the arguments from the `main()` function and also a pointer to the user-defined `struct fuse_operations`.

It will take care of initializing the communication with the kernel module `fuse.ko` and it will wait for callbacks.

When an user issues a write to a FUSE file, the generic kernel `write()` interface will determine the filesystem of the file. 
If it's a FUSE file, it will forward the `write` request to the kernel module `fuse.ko`, which will use the callback we defined to complete the `write` request.

[Image](/assets/blog/2022/FUSE-exploit/fuse_arch.png)

So, in order to create a minimal FUSE filesystem is required to:

* Define all callbacks for operations supported by the filesystem.
* Declare of the `struct fuse_operations` with all function pointers
* Call to `fuse_main()`

And that's it!

## Goodbye userfaultfd, welcome FUSE!

With `userfaultfd` it's possible to pause a kernel thread during the execution of a `copy_from_user`, using an `mmap()`ed chunk of memory with zero-demand paging[ยน](https://man7.org/linux/man-pages/man2/userfaultfd.2.html).

With FUSE, an unprivileged user can create its own filesystem...how could it be exploited to pause a kernel thread?

The idea is that when a file is `mmap()`ed in memory, it's `mmap()`ed using zero-demand paging as well.
This means that the first read or write to that memory will cause a `read()` of the file from disk, in order to be copied into memory.

```c
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <assert.h>
#include <string.h>
int main(){
	int fd = open("fuse_dir/lol", O_RDWR);
	void *addr = mmap(0x1000, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
	// mmap()ed the file in zero-demand paging
	printf("No read done from FUSE\n");
	assert(addr != -1);
	printf("Triggering read from FUSE\n");
	//THIS will trigger the call to FUSE read
	printf("%s\n", (char *)addr);
}
```

Well, since we have to handle all file operations to files in the FUSE filesystem from userspace,
this will trigger the `read()` we defined in the FUSE filesystem.

We control what `read()` does, so we could, for example, simply call in a `for` loop `sleep()`.
If a kernel thread executes a `copy_from_user()` on the FUSE `mmap()`ed file, this will pause the kernel thread.

```c
#define FILE_TARGET "/lol"

static int FUSE_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi){
    if(strcmp(path, FILE_TARGET) == 0){
        for(;;){
            printf("[+] Pausing kernel thread...\n");
            sleep(100);
        }
    }
    return 0;
}
```

This is the result:

[It works :)](/assets/blog/2022/FUSE-exploit/FUSE.jpg)


## Conclusion

Building a FUSE filesystem it's a good alternative to `userfaultfd` technique when developing kernel exploits, since `userfaultfd` is not enabled by default anymore
for unprivileged users on almost all major linux distributions.

CVE-2022-2602 writeup coming soon, stay tuned! :)
